/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Finest API
 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { http } from '../client/http';
export type GetAllTransactionsParams = {
limit?: string;
};

export type GetAllTransactions200TransactionsItem = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  paymentTypeIcon: string;
  tagName: string;
  tagColor: string;
};

export type GetAllTransactions200Transactions = {[key: string]: GetAllTransactions200TransactionsItem[]};

export type GetAllTransactions200 = {
  transactions: GetAllTransactions200Transactions;
};

export type GetAllTransactions500 = {
  name: string;
  message: string;
};

export type GetTransactionByIdParams = {
id: string;
};

export type GetTransactionById200 = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  tagName: string;
  tagColor: string;
};

export type GetTransactionById404 = {
  name: string;
  message: string;
};

export type GetAllTransactionsByPaymentTypeParams = {
paymentTypeId: string;
paymentTypeName?: string;
};

export type GetAllTransactionsByPaymentType200TransactionsItem = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  tagName: string;
  tagColor: string;
};

export type GetAllTransactionsByPaymentType200 = {
  transactions: GetAllTransactionsByPaymentType200TransactionsItem[];
};

export type GetAllTransactionsByPaymentType400 = {
  name: string;
  message: string;
};

export type GetAllTransactionsByPaymentType404 = {
  name: string;
  message: string;
};

export type GetAllTransactionsByTagParams = {
tagId: string;
tagName?: string;
};

export type GetAllTransactionsByTag200TransactionsItem = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  tagGoal: number;
  tagName: string;
  tagColor: string;
};

export type GetAllTransactionsByTag200 = {
  transactions: GetAllTransactionsByTag200TransactionsItem[];
};

export type GetAllTransactionsByTag400 = {
  name: string;
  message: string;
};

export type GetAllTransactionsByTag404 = {
  name: string;
  message: string;
};

export type GetAllTransactionsByMonthParams = {
month: string;
year?: string;
};

export type GetAllTransactionsByMonth200TransactionsSpendsItem = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  paymentTypeIcon: string;
  tagName: string;
  tagColor: string;
};

export type GetAllTransactionsByMonth200TransactionsIncomesItem = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  paymentTypeIcon: string;
  tagName: string;
  tagColor: string;
};

export type GetAllTransactionsByMonth200TransactionsDetails = {
  totalSpends: number;
  totalIncomes: number;
  overallBalance: number;
};

export type GetAllTransactionsByMonth200Transactions = {
  spends: GetAllTransactionsByMonth200TransactionsSpendsItem[];
  incomes: GetAllTransactionsByMonth200TransactionsIncomesItem[];
  details: GetAllTransactionsByMonth200TransactionsDetails;
};

export type GetAllTransactionsByMonth200 = {
  month: number;
  year: number;
  transactions: GetAllTransactionsByMonth200Transactions;
};

export type GetAllTransactionsByMonth400 = {
  name: string;
  message: string;
};

export type GetAllTransactionsByMonth404 = {
  name: string;
  message: string;
};

export type GetAllTransactionsWithMonthParams = {
month?: string;
year?: string;
};

export type GetAllTransactionsWithMonth200SpendsItem = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  paymentTypeIcon: string;
  tagName: string;
  tagColor: string;
};

export type GetAllTransactionsWithMonth200IncomesItem = {
  id: number;
  /** @nullable */
  createdAt: string | null;
  isSpend: boolean;
  amount: number;
  paymentType: string;
  paymentTypeIcon: string;
  tagName: string;
  tagColor: string;
};

export type GetAllTransactionsWithMonth200Details = {
  totalSpends: number;
  totalIncomes: number;
  overallBalance: number;
};

export type GetAllTransactionsWithMonth200 = {[key: string]: {
  spends: GetAllTransactionsWithMonth200SpendsItem[];
  incomes: GetAllTransactionsWithMonth200IncomesItem[];
  details: GetAllTransactionsWithMonth200Details;
}};

export type GetAllTransactionsWithMonth400 = {
  name: string;
  message: string;
};

export type GetAllTransactionsWithMonth404 = {
  name: string;
  message: string;
};

export type CreateTransactionBody = {
  amount: number;
  isSpend: boolean;
  paymentTypeId: number;
  tagId: number;
  createdAt?: string;
};

export type CreateTransaction200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  amount: number;
  /** @nullable */
  createdAt?: string | null;
  isSpend: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  paymentTypeId?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  tagId?: number;
  /** @nullable */
  removedAt?: string | null;
};

export type CreateTransaction404 = {
  name: string;
  message: string;
};

export type GetLastAmount200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  total: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  lastAmount: number | null;
  /** @nullable */
  createdAt: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  lastTransaction: number;
};

export type GetLastAmount500 = {
  name: string;
  message: string;
};

export type GetMonthAmountParams = {
month: string;
year?: string;
last?: string;
};

export type GetMonthAmount200Item = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  total: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  lastAmount: number | null;
  /** @nullable */
  createdAt: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  lastTransaction: number;
};

export type GetMonthAmount500 = {
  name: string;
  message: string;
};

export type GetRoughAmount500 = {
  name: string;
  message: string;
};

export type GetAllTags200TagsItem = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 255 */
  color: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  monthGoal: number;
  /** @nullable */
  createdAt: string | null;
  /** @nullable */
  updatedAt: string | null;
  /** @nullable */
  removedAt: string | null;
};

export type GetAllTags200 = {
  tags: GetAllTags200TagsItem[];
};

export type GetAllTags500 = {
  name: string;
  message: string;
};

export type GetTagParams = {
id?: string;
name?: string;
};

export type GetTag200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 255 */
  color: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  monthGoal: number;
  /** @nullable */
  createdAt: string | null;
  /** @nullable */
  updatedAt: string | null;
  /** @nullable */
  removedAt: string | null;
};

export type GetTag400 = {
  name: string;
  message: string;
};

export type GetTag404 = {
  name: string;
  message: string;
};

export type GetAllRemovedTags200TagsItem = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 255 */
  color: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  monthGoal: number;
  /** @nullable */
  createdAt: string | null;
  /** @nullable */
  updatedAt: string | null;
  /** @nullable */
  removedAt: string | null;
};

export type GetAllRemovedTags200 = {
  tags: GetAllRemovedTags200TagsItem[];
};

export type GetAllRemovedTags500 = {
  name: string;
  message: string;
};

export type GetMostUsedTagsParams = {
limit?: string;
};

export type GetMostUsedTags200Item = {
  id: number;
  name: string;
  color: string;
  monthGoal: number;
  usageCount: number;
};

export type GetMostUsedTags500 = {
  name: string;
  message: string;
};

export type GetAllTagsWithSpendsParams = {
month: string;
year?: string;
};

export type GetAllTagsWithSpends200Item = {
  id: number;
  name: string;
  color: string;
  monthGoal: number;
  total: number;
};

export type GetAllTagsWithSpends500 = {
  name: string;
  message: string;
};

export type DownloadTagsWithSpendsParams = {
year?: string;
};

export type CreateTagBody = {
  name: string;
  color: string;
  description?: string;
  monthGoal?: number;
};

export type CreateTag201 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 255 */
  color: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  monthGoal?: number;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type CreateTag500 = {
  name: string;
  message: string;
};

export type UpdateTagBody = {
  id: number;
  name?: string;
  color: string;
  description?: string;
  monthGoal: number;
};

export type UpdateTag200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name?: string;
  /** @maxLength 255 */
  color?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  monthGoal?: number;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type UpdateTag404 = {
  name: string;
  message: string;
};

export type RemoveTag200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name?: string;
  /** @maxLength 255 */
  color?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  monthGoal?: number;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type RemoveTag404 = {
  name: string;
  message: string;
};

export type RestoreTag200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name?: string;
  /** @maxLength 255 */
  color?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  monthGoal?: number;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type RestoreTag404 = {
  name: string;
  message: string;
};

export type GetAllPaymentTypes200PaymentTypesItem = {
  id: number;
  name: string;
  /** @nullable */
  description: string | null;
  icon: string;
  /** @nullable */
  createdAt: string | null;
  /** @nullable */
  updatedAt: string | null;
};

export type GetAllPaymentTypes200 = {
  paymentTypes: GetAllPaymentTypes200PaymentTypesItem[];
};

export type GetAllPaymentTypes500 = {
  name: string;
  message: string;
};

export type GetAllRemovedPaymentTypes200PaymentTypesItem = {
  id: number;
  name: string;
  /** @nullable */
  description: string | null;
  icon: string;
  /** @nullable */
  createdAt: string | null;
  /** @nullable */
  updatedAt: string | null;
};

export type GetAllRemovedPaymentTypes200 = {
  paymentTypes: GetAllRemovedPaymentTypes200PaymentTypesItem[];
};

export type GetAllRemovedPaymentTypes500 = {
  name: string;
  message: string;
};

export type GetPaymentTypeParams = {
id?: string;
name?: string;
};

export type GetPaymentType200 = {
  id: number;
  name: string;
  /** @nullable */
  description: string | null;
  icon: string;
  /** @nullable */
  createdAt: string | null;
  /** @nullable */
  updatedAt: string | null;
};

export type GetPaymentType400 = {
  name: string;
  message: string;
};

export type GetPaymentType404 = {
  name: string;
  message: string;
};

export type GetMostUsedPaymentTypesParams = {
limit?: string;
};

export type GetMostUsedPaymentTypes200Item = {
  id: number;
  name: string;
  icon: string;
  usageCount: number;
};

export type GetMostUsedPaymentTypes500 = {
  name: string;
  message: string;
};

export type CreatePaymentTypeBody = {
  name: string;
  description?: string;
  icon: string;
};

export type CreatePaymentType201 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 255 */
  icon: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type CreatePaymentType409 = {
  name: string;
  message: string;
};

export type UpdatePaymentTypeBody = {
  id: number;
  name?: string;
  description?: string;
  icon?: string;
};

export type UpdatePaymentType200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name?: string;
  /** @maxLength 255 */
  icon?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type UpdatePaymentType404 = {
  name: string;
  message: string;
};

export type RemovePaymentType200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name?: string;
  /** @maxLength 255 */
  icon?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type RemovePaymentType404 = {
  name: string;
  message: string;
};

export type RestorePaymentType200 = {
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  id?: number;
  /** @maxLength 255 */
  name?: string;
  /** @maxLength 255 */
  icon?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  description?: string | null;
  /** @nullable */
  createdAt?: string | null;
  /** @nullable */
  updatedAt?: string | null;
  /** @nullable */
  removedAt?: string | null;
};

export type RestorePaymentType404 = {
  name: string;
  message: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Get all transactions
 */
export const getGetAllTransactionsUrl = (params?: GetAllTransactionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/transactions/all?${stringifiedParams}` : `http://localhost:3030/transactions/all`
}

export const getAllTransactions = async (params?: GetAllTransactionsParams, options?: RequestInit): Promise<GetAllTransactions200> => {
  
  return http<GetAllTransactions200>(getGetAllTransactionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllTransactionsQueryKey = (params?: GetAllTransactionsParams,) => {
    return [`http://localhost:3030/transactions/all`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getAllTransactions>>, TError = GetAllTransactions500>(params?: GetAllTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactions>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTransactionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTransactions>>> = ({ signal }) => getAllTransactions(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTransactions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTransactions>>>
export type GetAllTransactionsQueryError = GetAllTransactions500


export function useGetAllTransactions<TData = Awaited<ReturnType<typeof getAllTransactions>>, TError = GetAllTransactions500>(
 params: undefined |  GetAllTransactionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactions>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactions<TData = Awaited<ReturnType<typeof getAllTransactions>>, TError = GetAllTransactions500>(
 params?: GetAllTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactions>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactions<TData = Awaited<ReturnType<typeof getAllTransactions>>, TError = GetAllTransactions500>(
 params?: GetAllTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactions>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all transactions
 */

export function useGetAllTransactions<TData = Awaited<ReturnType<typeof getAllTransactions>>, TError = GetAllTransactions500>(
 params?: GetAllTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactions>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a transaction by id
 */
export const getGetTransactionByIdUrl = (params: GetTransactionByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/transactions?${stringifiedParams}` : `http://localhost:3030/transactions`
}

export const getTransactionById = async (params: GetTransactionByIdParams, options?: RequestInit): Promise<GetTransactionById200> => {
  
  return http<GetTransactionById200>(getGetTransactionByIdUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTransactionByIdQueryKey = (params: GetTransactionByIdParams,) => {
    return [`http://localhost:3030/transactions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTransactionByIdQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionById>>, TError = GetTransactionById404>(params: GetTransactionByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionById>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionByIdQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionById>>> = ({ signal }) => getTransactionById(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionById>>>
export type GetTransactionByIdQueryError = GetTransactionById404


export function useGetTransactionById<TData = Awaited<ReturnType<typeof getTransactionById>>, TError = GetTransactionById404>(
 params: GetTransactionByIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionById>>,
          TError,
          Awaited<ReturnType<typeof getTransactionById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionById<TData = Awaited<ReturnType<typeof getTransactionById>>, TError = GetTransactionById404>(
 params: GetTransactionByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionById>>,
          TError,
          Awaited<ReturnType<typeof getTransactionById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionById<TData = Awaited<ReturnType<typeof getTransactionById>>, TError = GetTransactionById404>(
 params: GetTransactionByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionById>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a transaction by id
 */

export function useGetTransactionById<TData = Awaited<ReturnType<typeof getTransactionById>>, TError = GetTransactionById404>(
 params: GetTransactionByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionById>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionByIdQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all transactions from a specific payment type
 */
export const getGetAllTransactionsByPaymentTypeUrl = (params: GetAllTransactionsByPaymentTypeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/transactions/payment-type?${stringifiedParams}` : `http://localhost:3030/transactions/payment-type`
}

export const getAllTransactionsByPaymentType = async (params: GetAllTransactionsByPaymentTypeParams, options?: RequestInit): Promise<GetAllTransactionsByPaymentType200> => {
  
  return http<GetAllTransactionsByPaymentType200>(getGetAllTransactionsByPaymentTypeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllTransactionsByPaymentTypeQueryKey = (params: GetAllTransactionsByPaymentTypeParams,) => {
    return [`http://localhost:3030/transactions/payment-type`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllTransactionsByPaymentTypeQueryOptions = <TData = Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError = GetAllTransactionsByPaymentType400 | GetAllTransactionsByPaymentType404>(params: GetAllTransactionsByPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTransactionsByPaymentTypeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>> = ({ signal }) => getAllTransactionsByPaymentType(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTransactionsByPaymentTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>>
export type GetAllTransactionsByPaymentTypeQueryError = GetAllTransactionsByPaymentType400 | GetAllTransactionsByPaymentType404


export function useGetAllTransactionsByPaymentType<TData = Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError = GetAllTransactionsByPaymentType400 | GetAllTransactionsByPaymentType404>(
 params: GetAllTransactionsByPaymentTypeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsByPaymentType<TData = Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError = GetAllTransactionsByPaymentType400 | GetAllTransactionsByPaymentType404>(
 params: GetAllTransactionsByPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsByPaymentType<TData = Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError = GetAllTransactionsByPaymentType400 | GetAllTransactionsByPaymentType404>(
 params: GetAllTransactionsByPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all transactions from a specific payment type
 */

export function useGetAllTransactionsByPaymentType<TData = Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError = GetAllTransactionsByPaymentType400 | GetAllTransactionsByPaymentType404>(
 params: GetAllTransactionsByPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByPaymentType>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTransactionsByPaymentTypeQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all transactions from a specific tag
 */
export const getGetAllTransactionsByTagUrl = (params: GetAllTransactionsByTagParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/transactions/tag?${stringifiedParams}` : `http://localhost:3030/transactions/tag`
}

export const getAllTransactionsByTag = async (params: GetAllTransactionsByTagParams, options?: RequestInit): Promise<GetAllTransactionsByTag200> => {
  
  return http<GetAllTransactionsByTag200>(getGetAllTransactionsByTagUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllTransactionsByTagQueryKey = (params: GetAllTransactionsByTagParams,) => {
    return [`http://localhost:3030/transactions/tag`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllTransactionsByTagQueryOptions = <TData = Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError = GetAllTransactionsByTag400 | GetAllTransactionsByTag404>(params: GetAllTransactionsByTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTransactionsByTagQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTransactionsByTag>>> = ({ signal }) => getAllTransactionsByTag(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTransactionsByTagQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTransactionsByTag>>>
export type GetAllTransactionsByTagQueryError = GetAllTransactionsByTag400 | GetAllTransactionsByTag404


export function useGetAllTransactionsByTag<TData = Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError = GetAllTransactionsByTag400 | GetAllTransactionsByTag404>(
 params: GetAllTransactionsByTagParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsByTag>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsByTag>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsByTag<TData = Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError = GetAllTransactionsByTag400 | GetAllTransactionsByTag404>(
 params: GetAllTransactionsByTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsByTag>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsByTag>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsByTag<TData = Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError = GetAllTransactionsByTag400 | GetAllTransactionsByTag404>(
 params: GetAllTransactionsByTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all transactions from a specific tag
 */

export function useGetAllTransactionsByTag<TData = Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError = GetAllTransactionsByTag400 | GetAllTransactionsByTag404>(
 params: GetAllTransactionsByTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByTag>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTransactionsByTagQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all transactions from a specific month
 */
export const getGetAllTransactionsByMonthUrl = (params: GetAllTransactionsByMonthParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/transactions/month?${stringifiedParams}` : `http://localhost:3030/transactions/month`
}

export const getAllTransactionsByMonth = async (params: GetAllTransactionsByMonthParams, options?: RequestInit): Promise<GetAllTransactionsByMonth200> => {
  
  return http<GetAllTransactionsByMonth200>(getGetAllTransactionsByMonthUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllTransactionsByMonthQueryKey = (params: GetAllTransactionsByMonthParams,) => {
    return [`http://localhost:3030/transactions/month`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllTransactionsByMonthQueryOptions = <TData = Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError = GetAllTransactionsByMonth400 | GetAllTransactionsByMonth404>(params: GetAllTransactionsByMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTransactionsByMonthQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTransactionsByMonth>>> = ({ signal }) => getAllTransactionsByMonth(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTransactionsByMonthQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTransactionsByMonth>>>
export type GetAllTransactionsByMonthQueryError = GetAllTransactionsByMonth400 | GetAllTransactionsByMonth404


export function useGetAllTransactionsByMonth<TData = Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError = GetAllTransactionsByMonth400 | GetAllTransactionsByMonth404>(
 params: GetAllTransactionsByMonthParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsByMonth>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsByMonth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsByMonth<TData = Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError = GetAllTransactionsByMonth400 | GetAllTransactionsByMonth404>(
 params: GetAllTransactionsByMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsByMonth>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsByMonth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsByMonth<TData = Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError = GetAllTransactionsByMonth400 | GetAllTransactionsByMonth404>(
 params: GetAllTransactionsByMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all transactions from a specific month
 */

export function useGetAllTransactionsByMonth<TData = Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError = GetAllTransactionsByMonth400 | GetAllTransactionsByMonth404>(
 params: GetAllTransactionsByMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsByMonth>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTransactionsByMonthQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all transactions from a specific range of months
 */
export const getGetAllTransactionsWithMonthUrl = (params?: GetAllTransactionsWithMonthParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/transactions/with-month?${stringifiedParams}` : `http://localhost:3030/transactions/with-month`
}

export const getAllTransactionsWithMonth = async (params?: GetAllTransactionsWithMonthParams, options?: RequestInit): Promise<GetAllTransactionsWithMonth200> => {
  
  return http<GetAllTransactionsWithMonth200>(getGetAllTransactionsWithMonthUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllTransactionsWithMonthQueryKey = (params?: GetAllTransactionsWithMonthParams,) => {
    return [`http://localhost:3030/transactions/with-month`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllTransactionsWithMonthQueryOptions = <TData = Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError = GetAllTransactionsWithMonth400 | GetAllTransactionsWithMonth404>(params?: GetAllTransactionsWithMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTransactionsWithMonthQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>> = ({ signal }) => getAllTransactionsWithMonth(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTransactionsWithMonthQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>>
export type GetAllTransactionsWithMonthQueryError = GetAllTransactionsWithMonth400 | GetAllTransactionsWithMonth404


export function useGetAllTransactionsWithMonth<TData = Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError = GetAllTransactionsWithMonth400 | GetAllTransactionsWithMonth404>(
 params: undefined |  GetAllTransactionsWithMonthParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsWithMonth>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsWithMonth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsWithMonth<TData = Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError = GetAllTransactionsWithMonth400 | GetAllTransactionsWithMonth404>(
 params?: GetAllTransactionsWithMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTransactionsWithMonth>>,
          TError,
          Awaited<ReturnType<typeof getAllTransactionsWithMonth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTransactionsWithMonth<TData = Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError = GetAllTransactionsWithMonth400 | GetAllTransactionsWithMonth404>(
 params?: GetAllTransactionsWithMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all transactions from a specific range of months
 */

export function useGetAllTransactionsWithMonth<TData = Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError = GetAllTransactionsWithMonth400 | GetAllTransactionsWithMonth404>(
 params?: GetAllTransactionsWithMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTransactionsWithMonth>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTransactionsWithMonthQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a transaction
 */
export const getCreateTransactionUrl = () => {


  

  return `http://localhost:3030/transactions/create`
}

export const createTransaction = async (createTransactionBody: CreateTransactionBody, options?: RequestInit): Promise<CreateTransaction200> => {
  
  return http<CreateTransaction200>(getCreateTransactionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTransactionBody,)
  }
);}




export const getCreateTransactionMutationOptions = <TError = CreateTransaction404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransaction>>, TError,{data: CreateTransactionBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createTransaction>>, TError,{data: CreateTransactionBody}, TContext> => {
    
const mutationKey = ['createTransaction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTransaction>>, {data: CreateTransactionBody}> = (props) => {
          const {data} = props ?? {};

          return  createTransaction(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof createTransaction>>>
    export type CreateTransactionMutationBody = CreateTransactionBody
    export type CreateTransactionMutationError = CreateTransaction404

    /**
 * @summary Create a transaction
 */
export const useCreateTransaction = <TError = CreateTransaction404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransaction>>, TError,{data: CreateTransactionBody}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTransaction>>,
        TError,
        {data: CreateTransactionBody},
        TContext
      > => {

      const mutationOptions = getCreateTransactionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get last total amount
 */
export const getGetLastAmountUrl = () => {


  

  return `http://localhost:3030/total-amount/`
}

export const getLastAmount = async ( options?: RequestInit): Promise<GetLastAmount200> => {
  
  return http<GetLastAmount200>(getGetLastAmountUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetLastAmountQueryKey = () => {
    return [`http://localhost:3030/total-amount/`] as const;
    }

    
export const getGetLastAmountQueryOptions = <TData = Awaited<ReturnType<typeof getLastAmount>>, TError = GetLastAmount500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLastAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLastAmountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLastAmount>>> = ({ signal }) => getLastAmount({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLastAmount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLastAmountQueryResult = NonNullable<Awaited<ReturnType<typeof getLastAmount>>>
export type GetLastAmountQueryError = GetLastAmount500


export function useGetLastAmount<TData = Awaited<ReturnType<typeof getLastAmount>>, TError = GetLastAmount500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLastAmount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLastAmount>>,
          TError,
          Awaited<ReturnType<typeof getLastAmount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLastAmount<TData = Awaited<ReturnType<typeof getLastAmount>>, TError = GetLastAmount500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLastAmount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLastAmount>>,
          TError,
          Awaited<ReturnType<typeof getLastAmount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLastAmount<TData = Awaited<ReturnType<typeof getLastAmount>>, TError = GetLastAmount500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLastAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get last total amount
 */

export function useGetLastAmount<TData = Awaited<ReturnType<typeof getLastAmount>>, TError = GetLastAmount500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLastAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLastAmountQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get total amount from a specific month
 */
export const getGetMonthAmountUrl = (params: GetMonthAmountParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/total-amount/month?${stringifiedParams}` : `http://localhost:3030/total-amount/month`
}

export const getMonthAmount = async (params: GetMonthAmountParams, options?: RequestInit): Promise<GetMonthAmount200Item[]> => {
  
  return http<GetMonthAmount200Item[]>(getGetMonthAmountUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetMonthAmountQueryKey = (params: GetMonthAmountParams,) => {
    return [`http://localhost:3030/total-amount/month`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMonthAmountQueryOptions = <TData = Awaited<ReturnType<typeof getMonthAmount>>, TError = GetMonthAmount500>(params: GetMonthAmountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMonthAmountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthAmount>>> = ({ signal }) => getMonthAmount(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMonthAmount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMonthAmountQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthAmount>>>
export type GetMonthAmountQueryError = GetMonthAmount500


export function useGetMonthAmount<TData = Awaited<ReturnType<typeof getMonthAmount>>, TError = GetMonthAmount500>(
 params: GetMonthAmountParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthAmount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthAmount>>,
          TError,
          Awaited<ReturnType<typeof getMonthAmount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMonthAmount<TData = Awaited<ReturnType<typeof getMonthAmount>>, TError = GetMonthAmount500>(
 params: GetMonthAmountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthAmount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthAmount>>,
          TError,
          Awaited<ReturnType<typeof getMonthAmount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMonthAmount<TData = Awaited<ReturnType<typeof getMonthAmount>>, TError = GetMonthAmount500>(
 params: GetMonthAmountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get total amount from a specific month
 */

export function useGetMonthAmount<TData = Awaited<ReturnType<typeof getMonthAmount>>, TError = GetMonthAmount500>(
 params: GetMonthAmountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMonthAmountQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get last total amount in number
 */
export const getGetRoughAmountUrl = () => {


  

  return `http://localhost:3030/total-amount/number`
}

export const getRoughAmount = async ( options?: RequestInit): Promise<number> => {
  
  return http<number>(getGetRoughAmountUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetRoughAmountQueryKey = () => {
    return [`http://localhost:3030/total-amount/number`] as const;
    }

    
export const getGetRoughAmountQueryOptions = <TData = Awaited<ReturnType<typeof getRoughAmount>>, TError = GetRoughAmount500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoughAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoughAmountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoughAmount>>> = ({ signal }) => getRoughAmount({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoughAmount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoughAmountQueryResult = NonNullable<Awaited<ReturnType<typeof getRoughAmount>>>
export type GetRoughAmountQueryError = GetRoughAmount500


export function useGetRoughAmount<TData = Awaited<ReturnType<typeof getRoughAmount>>, TError = GetRoughAmount500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoughAmount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoughAmount>>,
          TError,
          Awaited<ReturnType<typeof getRoughAmount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoughAmount<TData = Awaited<ReturnType<typeof getRoughAmount>>, TError = GetRoughAmount500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoughAmount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoughAmount>>,
          TError,
          Awaited<ReturnType<typeof getRoughAmount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoughAmount<TData = Awaited<ReturnType<typeof getRoughAmount>>, TError = GetRoughAmount500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoughAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get last total amount in number
 */

export function useGetRoughAmount<TData = Awaited<ReturnType<typeof getRoughAmount>>, TError = GetRoughAmount500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoughAmount>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoughAmountQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all tags
 */
export const getGetAllTagsUrl = () => {


  

  return `http://localhost:3030/tags/all`
}

export const getAllTags = async ( options?: RequestInit): Promise<GetAllTags200> => {
  
  return http<GetAllTags200>(getGetAllTagsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllTagsQueryKey = () => {
    return [`http://localhost:3030/tags/all`] as const;
    }

    
export const getGetAllTagsQueryOptions = <TData = Awaited<ReturnType<typeof getAllTags>>, TError = GetAllTags500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTagsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTags>>> = ({ signal }) => getAllTags({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTags>>>
export type GetAllTagsQueryError = GetAllTags500


export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = GetAllTags500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = GetAllTags500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTags>>,
          TError,
          Awaited<ReturnType<typeof getAllTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = GetAllTags500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all tags
 */

export function useGetAllTags<TData = Awaited<ReturnType<typeof getAllTags>>, TError = GetAllTags500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTagsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get tag by id or name
 */
export const getGetTagUrl = (params?: GetTagParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/tags?${stringifiedParams}` : `http://localhost:3030/tags`
}

export const getTag = async (params?: GetTagParams, options?: RequestInit): Promise<GetTag200> => {
  
  return http<GetTag200>(getGetTagUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTagQueryKey = (params?: GetTagParams,) => {
    return [`http://localhost:3030/tags`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTagQueryOptions = <TData = Awaited<ReturnType<typeof getTag>>, TError = GetTag400 | GetTag404>(params?: GetTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTagQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTag>>> = ({ signal }) => getTag(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTagQueryResult = NonNullable<Awaited<ReturnType<typeof getTag>>>
export type GetTagQueryError = GetTag400 | GetTag404


export function useGetTag<TData = Awaited<ReturnType<typeof getTag>>, TError = GetTag400 | GetTag404>(
 params: undefined |  GetTagParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTag>>,
          TError,
          Awaited<ReturnType<typeof getTag>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTag<TData = Awaited<ReturnType<typeof getTag>>, TError = GetTag400 | GetTag404>(
 params?: GetTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTag>>,
          TError,
          Awaited<ReturnType<typeof getTag>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTag<TData = Awaited<ReturnType<typeof getTag>>, TError = GetTag400 | GetTag404>(
 params?: GetTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get tag by id or name
 */

export function useGetTag<TData = Awaited<ReturnType<typeof getTag>>, TError = GetTag400 | GetTag404>(
 params?: GetTagParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTag>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTagQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all removed tags
 */
export const getGetAllRemovedTagsUrl = () => {


  

  return `http://localhost:3030/tags/all-removed`
}

export const getAllRemovedTags = async ( options?: RequestInit): Promise<GetAllRemovedTags200> => {
  
  return http<GetAllRemovedTags200>(getGetAllRemovedTagsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllRemovedTagsQueryKey = () => {
    return [`http://localhost:3030/tags/all-removed`] as const;
    }

    
export const getGetAllRemovedTagsQueryOptions = <TData = Awaited<ReturnType<typeof getAllRemovedTags>>, TError = GetAllRemovedTags500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllRemovedTagsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRemovedTags>>> = ({ signal }) => getAllRemovedTags({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllRemovedTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllRemovedTags>>>
export type GetAllRemovedTagsQueryError = GetAllRemovedTags500


export function useGetAllRemovedTags<TData = Awaited<ReturnType<typeof getAllRemovedTags>>, TError = GetAllRemovedTags500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllRemovedTags>>,
          TError,
          Awaited<ReturnType<typeof getAllRemovedTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllRemovedTags<TData = Awaited<ReturnType<typeof getAllRemovedTags>>, TError = GetAllRemovedTags500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllRemovedTags>>,
          TError,
          Awaited<ReturnType<typeof getAllRemovedTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllRemovedTags<TData = Awaited<ReturnType<typeof getAllRemovedTags>>, TError = GetAllRemovedTags500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all removed tags
 */

export function useGetAllRemovedTags<TData = Awaited<ReturnType<typeof getAllRemovedTags>>, TError = GetAllRemovedTags500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllRemovedTagsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get most used tags
 */
export const getGetMostUsedTagsUrl = (params?: GetMostUsedTagsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/tags/most-used?${stringifiedParams}` : `http://localhost:3030/tags/most-used`
}

export const getMostUsedTags = async (params?: GetMostUsedTagsParams, options?: RequestInit): Promise<GetMostUsedTags200Item[]> => {
  
  return http<GetMostUsedTags200Item[]>(getGetMostUsedTagsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetMostUsedTagsQueryKey = (params?: GetMostUsedTagsParams,) => {
    return [`http://localhost:3030/tags/most-used`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMostUsedTagsQueryOptions = <TData = Awaited<ReturnType<typeof getMostUsedTags>>, TError = GetMostUsedTags500>(params?: GetMostUsedTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMostUsedTagsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMostUsedTags>>> = ({ signal }) => getMostUsedTags(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMostUsedTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMostUsedTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getMostUsedTags>>>
export type GetMostUsedTagsQueryError = GetMostUsedTags500


export function useGetMostUsedTags<TData = Awaited<ReturnType<typeof getMostUsedTags>>, TError = GetMostUsedTags500>(
 params: undefined |  GetMostUsedTagsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostUsedTags>>,
          TError,
          Awaited<ReturnType<typeof getMostUsedTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMostUsedTags<TData = Awaited<ReturnType<typeof getMostUsedTags>>, TError = GetMostUsedTags500>(
 params?: GetMostUsedTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostUsedTags>>,
          TError,
          Awaited<ReturnType<typeof getMostUsedTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMostUsedTags<TData = Awaited<ReturnType<typeof getMostUsedTags>>, TError = GetMostUsedTags500>(
 params?: GetMostUsedTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get most used tags
 */

export function useGetMostUsedTags<TData = Awaited<ReturnType<typeof getMostUsedTags>>, TError = GetMostUsedTags500>(
 params?: GetMostUsedTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedTags>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMostUsedTagsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all tags with their monthly goal and monthly total spent
 */
export const getGetAllTagsWithSpendsUrl = (params: GetAllTagsWithSpendsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/tags/with-spends?${stringifiedParams}` : `http://localhost:3030/tags/with-spends`
}

export const getAllTagsWithSpends = async (params: GetAllTagsWithSpendsParams, options?: RequestInit): Promise<GetAllTagsWithSpends200Item[]> => {
  
  return http<GetAllTagsWithSpends200Item[]>(getGetAllTagsWithSpendsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllTagsWithSpendsQueryKey = (params: GetAllTagsWithSpendsParams,) => {
    return [`http://localhost:3030/tags/with-spends`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllTagsWithSpendsQueryOptions = <TData = Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError = GetAllTagsWithSpends500>(params: GetAllTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllTagsWithSpendsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTagsWithSpends>>> = ({ signal }) => getAllTagsWithSpends(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllTagsWithSpendsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTagsWithSpends>>>
export type GetAllTagsWithSpendsQueryError = GetAllTagsWithSpends500


export function useGetAllTagsWithSpends<TData = Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError = GetAllTagsWithSpends500>(
 params: GetAllTagsWithSpendsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTagsWithSpends>>,
          TError,
          Awaited<ReturnType<typeof getAllTagsWithSpends>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTagsWithSpends<TData = Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError = GetAllTagsWithSpends500>(
 params: GetAllTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTagsWithSpends>>,
          TError,
          Awaited<ReturnType<typeof getAllTagsWithSpends>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllTagsWithSpends<TData = Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError = GetAllTagsWithSpends500>(
 params: GetAllTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all tags with their monthly goal and monthly total spent
 */

export function useGetAllTagsWithSpends<TData = Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError = GetAllTagsWithSpends500>(
 params: GetAllTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTagsWithSpends>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllTagsWithSpendsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Exporta os gastos por tag at√© o m√™s atual como planilha Excel
 */
export const getDownloadTagsWithSpendsUrl = (params?: DownloadTagsWithSpendsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/tags/with-spends/download?${stringifiedParams}` : `http://localhost:3030/tags/with-spends/download`
}

export const downloadTagsWithSpends = async (params?: DownloadTagsWithSpendsParams, options?: RequestInit): Promise<void> => {
  
  return http<void>(getDownloadTagsWithSpendsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getDownloadTagsWithSpendsQueryKey = (params?: DownloadTagsWithSpendsParams,) => {
    return [`http://localhost:3030/tags/with-spends/download`, ...(params ? [params]: [])] as const;
    }

    
export const getDownloadTagsWithSpendsQueryOptions = <TData = Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError = unknown>(params?: DownloadTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadTagsWithSpendsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadTagsWithSpends>>> = ({ signal }) => downloadTagsWithSpends(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadTagsWithSpendsQueryResult = NonNullable<Awaited<ReturnType<typeof downloadTagsWithSpends>>>
export type DownloadTagsWithSpendsQueryError = unknown


export function useDownloadTagsWithSpends<TData = Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError = unknown>(
 params: undefined |  DownloadTagsWithSpendsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadTagsWithSpends>>,
          TError,
          Awaited<ReturnType<typeof downloadTagsWithSpends>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadTagsWithSpends<TData = Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError = unknown>(
 params?: DownloadTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadTagsWithSpends>>,
          TError,
          Awaited<ReturnType<typeof downloadTagsWithSpends>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadTagsWithSpends<TData = Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError = unknown>(
 params?: DownloadTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Exporta os gastos por tag at√© o m√™s atual como planilha Excel
 */

export function useDownloadTagsWithSpends<TData = Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError = unknown>(
 params?: DownloadTagsWithSpendsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadTagsWithSpends>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadTagsWithSpendsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create tag
 */
export const getCreateTagUrl = () => {


  

  return `http://localhost:3030/tags/create`
}

export const createTag = async (createTagBody: CreateTagBody, options?: RequestInit): Promise<CreateTag201> => {
  
  return http<CreateTag201>(getCreateTagUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTagBody,)
  }
);}




export const getCreateTagMutationOptions = <TError = CreateTag500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTag>>, TError,{data: CreateTagBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createTag>>, TError,{data: CreateTagBody}, TContext> => {
    
const mutationKey = ['createTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTag>>, {data: CreateTagBody}> = (props) => {
          const {data} = props ?? {};

          return  createTag(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTagMutationResult = NonNullable<Awaited<ReturnType<typeof createTag>>>
    export type CreateTagMutationBody = CreateTagBody
    export type CreateTagMutationError = CreateTag500

    /**
 * @summary Create tag
 */
export const useCreateTag = <TError = CreateTag500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTag>>, TError,{data: CreateTagBody}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTag>>,
        TError,
        {data: CreateTagBody},
        TContext
      > => {

      const mutationOptions = getCreateTagMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update tag
 */
export const getUpdateTagUrl = () => {


  

  return `http://localhost:3030/tags/update`
}

export const updateTag = async (updateTagBody: UpdateTagBody, options?: RequestInit): Promise<UpdateTag200> => {
  
  return http<UpdateTag200>(getUpdateTagUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateTagBody,)
  }
);}




export const getUpdateTagMutationOptions = <TError = UpdateTag404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTag>>, TError,{data: UpdateTagBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTag>>, TError,{data: UpdateTagBody}, TContext> => {
    
const mutationKey = ['updateTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTag>>, {data: UpdateTagBody}> = (props) => {
          const {data} = props ?? {};

          return  updateTag(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTagMutationResult = NonNullable<Awaited<ReturnType<typeof updateTag>>>
    export type UpdateTagMutationBody = UpdateTagBody
    export type UpdateTagMutationError = UpdateTag404

    /**
 * @summary Update tag
 */
export const useUpdateTag = <TError = UpdateTag404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTag>>, TError,{data: UpdateTagBody}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTag>>,
        TError,
        {data: UpdateTagBody},
        TContext
      > => {

      const mutationOptions = getUpdateTagMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Remove tag
 */
export const getRemoveTagUrl = (id: string,) => {


  

  return `http://localhost:3030/tags/remove/${id}`
}

export const removeTag = async (id: string, options?: RequestInit): Promise<RemoveTag200> => {
  
  return http<RemoveTag200>(getRemoveTagUrl(id),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}




export const getRemoveTagMutationOptions = <TError = RemoveTag404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['removeTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTag>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  removeTag(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTagMutationResult = NonNullable<Awaited<ReturnType<typeof removeTag>>>
    
    export type RemoveTagMutationError = RemoveTag404

    /**
 * @summary Remove tag
 */
export const useRemoveTag = <TError = RemoveTag404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTag>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeTag>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getRemoveTagMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Restore tag
 */
export const getRestoreTagUrl = (id: string,) => {


  

  return `http://localhost:3030/tags/restore/${id}`
}

export const restoreTag = async (id: string, options?: RequestInit): Promise<RestoreTag200> => {
  
  return http<RestoreTag200>(getRestoreTagUrl(id),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}




export const getRestoreTagMutationOptions = <TError = RestoreTag404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restoreTag>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof restoreTag>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['restoreTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof restoreTag>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  restoreTag(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RestoreTagMutationResult = NonNullable<Awaited<ReturnType<typeof restoreTag>>>
    
    export type RestoreTagMutationError = RestoreTag404

    /**
 * @summary Restore tag
 */
export const useRestoreTag = <TError = RestoreTag404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restoreTag>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof restoreTag>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getRestoreTagMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all Payment Types
 */
export const getGetAllPaymentTypesUrl = () => {


  

  return `http://localhost:3030/payment-type/all`
}

export const getAllPaymentTypes = async ( options?: RequestInit): Promise<GetAllPaymentTypes200> => {
  
  return http<GetAllPaymentTypes200>(getGetAllPaymentTypesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllPaymentTypesQueryKey = () => {
    return [`http://localhost:3030/payment-type/all`] as const;
    }

    
export const getGetAllPaymentTypesQueryOptions = <TData = Awaited<ReturnType<typeof getAllPaymentTypes>>, TError = GetAllPaymentTypes500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllPaymentTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPaymentTypes>>> = ({ signal }) => getAllPaymentTypes({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllPaymentTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllPaymentTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPaymentTypes>>>
export type GetAllPaymentTypesQueryError = GetAllPaymentTypes500


export function useGetAllPaymentTypes<TData = Awaited<ReturnType<typeof getAllPaymentTypes>>, TError = GetAllPaymentTypes500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPaymentTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPaymentTypes>>,
          TError,
          Awaited<ReturnType<typeof getAllPaymentTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPaymentTypes<TData = Awaited<ReturnType<typeof getAllPaymentTypes>>, TError = GetAllPaymentTypes500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPaymentTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPaymentTypes>>,
          TError,
          Awaited<ReturnType<typeof getAllPaymentTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPaymentTypes<TData = Awaited<ReturnType<typeof getAllPaymentTypes>>, TError = GetAllPaymentTypes500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all Payment Types
 */

export function useGetAllPaymentTypes<TData = Awaited<ReturnType<typeof getAllPaymentTypes>>, TError = GetAllPaymentTypes500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllPaymentTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all removed Payment Types
 */
export const getGetAllRemovedPaymentTypesUrl = () => {


  

  return `http://localhost:3030/payment-type/all-removed`
}

export const getAllRemovedPaymentTypes = async ( options?: RequestInit): Promise<GetAllRemovedPaymentTypes200> => {
  
  return http<GetAllRemovedPaymentTypes200>(getGetAllRemovedPaymentTypesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAllRemovedPaymentTypesQueryKey = () => {
    return [`http://localhost:3030/payment-type/all-removed`] as const;
    }

    
export const getGetAllRemovedPaymentTypesQueryOptions = <TData = Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError = GetAllRemovedPaymentTypes500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllRemovedPaymentTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>> = ({ signal }) => getAllRemovedPaymentTypes({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllRemovedPaymentTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>>
export type GetAllRemovedPaymentTypesQueryError = GetAllRemovedPaymentTypes500


export function useGetAllRemovedPaymentTypes<TData = Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError = GetAllRemovedPaymentTypes500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>,
          TError,
          Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllRemovedPaymentTypes<TData = Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError = GetAllRemovedPaymentTypes500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>,
          TError,
          Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllRemovedPaymentTypes<TData = Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError = GetAllRemovedPaymentTypes500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all removed Payment Types
 */

export function useGetAllRemovedPaymentTypes<TData = Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError = GetAllRemovedPaymentTypes500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllRemovedPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllRemovedPaymentTypesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Payment Type by id or name
 */
export const getGetPaymentTypeUrl = (params?: GetPaymentTypeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/payment-type?${stringifiedParams}` : `http://localhost:3030/payment-type`
}

export const getPaymentType = async (params?: GetPaymentTypeParams, options?: RequestInit): Promise<GetPaymentType200> => {
  
  return http<GetPaymentType200>(getGetPaymentTypeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetPaymentTypeQueryKey = (params?: GetPaymentTypeParams,) => {
    return [`http://localhost:3030/payment-type`, ...(params ? [params]: [])] as const;
    }

    
export const getGetPaymentTypeQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentType>>, TError = GetPaymentType400 | GetPaymentType404>(params?: GetPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentType>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentTypeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentType>>> = ({ signal }) => getPaymentType(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPaymentTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentType>>>
export type GetPaymentTypeQueryError = GetPaymentType400 | GetPaymentType404


export function useGetPaymentType<TData = Awaited<ReturnType<typeof getPaymentType>>, TError = GetPaymentType400 | GetPaymentType404>(
 params: undefined |  GetPaymentTypeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentType>>,
          TError,
          Awaited<ReturnType<typeof getPaymentType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentType<TData = Awaited<ReturnType<typeof getPaymentType>>, TError = GetPaymentType400 | GetPaymentType404>(
 params?: GetPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentType>>,
          TError,
          Awaited<ReturnType<typeof getPaymentType>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentType<TData = Awaited<ReturnType<typeof getPaymentType>>, TError = GetPaymentType400 | GetPaymentType404>(
 params?: GetPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentType>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Payment Type by id or name
 */

export function useGetPaymentType<TData = Awaited<ReturnType<typeof getPaymentType>>, TError = GetPaymentType400 | GetPaymentType404>(
 params?: GetPaymentTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentType>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPaymentTypeQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get most used payment types
 */
export const getGetMostUsedPaymentTypesUrl = (params?: GetMostUsedPaymentTypesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3030/payment-type/most-used?${stringifiedParams}` : `http://localhost:3030/payment-type/most-used`
}

export const getMostUsedPaymentTypes = async (params?: GetMostUsedPaymentTypesParams, options?: RequestInit): Promise<GetMostUsedPaymentTypes200Item[]> => {
  
  return http<GetMostUsedPaymentTypes200Item[]>(getGetMostUsedPaymentTypesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetMostUsedPaymentTypesQueryKey = (params?: GetMostUsedPaymentTypesParams,) => {
    return [`http://localhost:3030/payment-type/most-used`, ...(params ? [params]: [])] as const;
    }

    
export const getGetMostUsedPaymentTypesQueryOptions = <TData = Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError = GetMostUsedPaymentTypes500>(params?: GetMostUsedPaymentTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMostUsedPaymentTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>> = ({ signal }) => getMostUsedPaymentTypes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMostUsedPaymentTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>>
export type GetMostUsedPaymentTypesQueryError = GetMostUsedPaymentTypes500


export function useGetMostUsedPaymentTypes<TData = Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError = GetMostUsedPaymentTypes500>(
 params: undefined |  GetMostUsedPaymentTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostUsedPaymentTypes>>,
          TError,
          Awaited<ReturnType<typeof getMostUsedPaymentTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMostUsedPaymentTypes<TData = Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError = GetMostUsedPaymentTypes500>(
 params?: GetMostUsedPaymentTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostUsedPaymentTypes>>,
          TError,
          Awaited<ReturnType<typeof getMostUsedPaymentTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMostUsedPaymentTypes<TData = Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError = GetMostUsedPaymentTypes500>(
 params?: GetMostUsedPaymentTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get most used payment types
 */

export function useGetMostUsedPaymentTypes<TData = Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError = GetMostUsedPaymentTypes500>(
 params?: GetMostUsedPaymentTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMostUsedPaymentTypes>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMostUsedPaymentTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Payment Type
 */
export const getCreatePaymentTypeUrl = () => {


  

  return `http://localhost:3030/payment-type/create`
}

export const createPaymentType = async (createPaymentTypeBody: CreatePaymentTypeBody, options?: RequestInit): Promise<CreatePaymentType201> => {
  
  return http<CreatePaymentType201>(getCreatePaymentTypeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPaymentTypeBody,)
  }
);}




export const getCreatePaymentTypeMutationOptions = <TError = CreatePaymentType409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPaymentType>>, TError,{data: CreatePaymentTypeBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createPaymentType>>, TError,{data: CreatePaymentTypeBody}, TContext> => {
    
const mutationKey = ['createPaymentType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPaymentType>>, {data: CreatePaymentTypeBody}> = (props) => {
          const {data} = props ?? {};

          return  createPaymentType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePaymentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createPaymentType>>>
    export type CreatePaymentTypeMutationBody = CreatePaymentTypeBody
    export type CreatePaymentTypeMutationError = CreatePaymentType409

    /**
 * @summary Create Payment Type
 */
export const useCreatePaymentType = <TError = CreatePaymentType409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPaymentType>>, TError,{data: CreatePaymentTypeBody}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPaymentType>>,
        TError,
        {data: CreatePaymentTypeBody},
        TContext
      > => {

      const mutationOptions = getCreatePaymentTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update Payment Type
 */
export const getUpdatePaymentTypeUrl = () => {


  

  return `http://localhost:3030/payment-type/update`
}

export const updatePaymentType = async (updatePaymentTypeBody: UpdatePaymentTypeBody, options?: RequestInit): Promise<UpdatePaymentType200> => {
  
  return http<UpdatePaymentType200>(getUpdatePaymentTypeUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePaymentTypeBody,)
  }
);}




export const getUpdatePaymentTypeMutationOptions = <TError = UpdatePaymentType404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentType>>, TError,{data: UpdatePaymentTypeBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePaymentType>>, TError,{data: UpdatePaymentTypeBody}, TContext> => {
    
const mutationKey = ['updatePaymentType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaymentType>>, {data: UpdatePaymentTypeBody}> = (props) => {
          const {data} = props ?? {};

          return  updatePaymentType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePaymentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaymentType>>>
    export type UpdatePaymentTypeMutationBody = UpdatePaymentTypeBody
    export type UpdatePaymentTypeMutationError = UpdatePaymentType404

    /**
 * @summary Update Payment Type
 */
export const useUpdatePaymentType = <TError = UpdatePaymentType404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentType>>, TError,{data: UpdatePaymentTypeBody}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePaymentType>>,
        TError,
        {data: UpdatePaymentTypeBody},
        TContext
      > => {

      const mutationOptions = getUpdatePaymentTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Remove a Payment Type
 */
export const getRemovePaymentTypeUrl = (id: string,) => {


  

  return `http://localhost:3030/payment-type/remove/${id}`
}

export const removePaymentType = async (id: string, options?: RequestInit): Promise<RemovePaymentType200> => {
  
  return http<RemovePaymentType200>(getRemovePaymentTypeUrl(id),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}




export const getRemovePaymentTypeMutationOptions = <TError = RemovePaymentType404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removePaymentType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof removePaymentType>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['removePaymentType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removePaymentType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  removePaymentType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemovePaymentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof removePaymentType>>>
    
    export type RemovePaymentTypeMutationError = RemovePaymentType404

    /**
 * @summary Remove a Payment Type
 */
export const useRemovePaymentType = <TError = RemovePaymentType404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removePaymentType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removePaymentType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getRemovePaymentTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Restore a Payment Type
 */
export const getRestorePaymentTypeUrl = (id: string,) => {


  

  return `http://localhost:3030/payment-type/restore/${id}`
}

export const restorePaymentType = async (id: string, options?: RequestInit): Promise<RestorePaymentType200> => {
  
  return http<RestorePaymentType200>(getRestorePaymentTypeUrl(id),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}




export const getRestorePaymentTypeMutationOptions = <TError = RestorePaymentType404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restorePaymentType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof restorePaymentType>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['restorePaymentType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof restorePaymentType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  restorePaymentType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RestorePaymentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof restorePaymentType>>>
    
    export type RestorePaymentTypeMutationError = RestorePaymentType404

    /**
 * @summary Restore a Payment Type
 */
export const useRestorePaymentType = <TError = RestorePaymentType404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restorePaymentType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof restorePaymentType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getRestorePaymentTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
